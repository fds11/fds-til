# 10/11 (목요일)  (현준, 소영)

## 1. Today I Learned

### 클로저

보통의 경우, 안쪽 스코프에서 정의된 변수는 바깥 스코프에서 접근할 수 없다.

```js
function func1(x) {
  return x;
}

func1(1);
// 더 이상 변수 `x`에 접근할 수 있는 방법이 없습니다.
```

```js
for (let i = 0; i < 10; i++) {
  console.log(i);
}
// 더 이상 변수 `i`에 접근할 수 있는 방법이 없습니다.
```

그런데, 안쪽 스코프에서 만들어진 함수에서 바깥 스코프의 변수를 사용하고 있다면, 이 함수를 통해서 변수를 계속 사용할 수 있다. 심지어 바깥 스코프에 해당하는 코드의 실행이 끝난 뒤라도 말이다.

```js
function func1(x) {
  // 여기서 반환되는 함수는 바깥 스코프에 있는 변수 `x`를 사용하고 있습니다.
  return function() {
    return x;
  };
}

const func2 = func1(1);

// `func1`의 실행은 끝났지만, `func2`를 통해서 변수 `x`를 사용할 수 있습니다.
console.log(func2()); // 1
```

```js
const arr = [];

for (let i = 0; i < 10; i++) {
  // 여기서 만들어진 함수는 바깥 스코프에 있는 변수 `i`를 사용하고 있습니다.
  arr.push(function() {
    return i;
  });
}

// for 루프의 실행은 끝났지만, 루프 안에서 만들어진 함수가 배열에 저장되어 있습니다.
// 배열 안에 들어있는 함수를 통해, 해당 함수가 만들어진 시점의 변수 `i`를 사용할 수 있습니다.
console.log(arr[2]()); // 2
console.log(arr[5]()); // 5
```

위와 같이, 1. **바깥 스코프에 있는 변수를 가져다 사용하는 함수**와, 2. 변수가 저장되는 저장소를 클로저(closure)라고 부른다.

## 2. Today I found Out

점점 이해하는 것이 힘겹다... 더욱 복습을 열심히 해서 뒤쳐지지 말자!

## 3. Reference 

[배열 관련 좋은 블로그 글 입니다.](http://bblog.tistory.com/300)