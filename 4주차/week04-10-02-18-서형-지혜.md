# 10/02 (화요일) 6조 (조서형, 황지혜)

## Today I Learned

---
### 객체

- 자료구조 : 여러 데이터를 담을 수 있는 통
- 객체 : JS 가 갖는 자료구조
- Wrapper 객체 : 객체가 아닌 것을 객체처럼 쓸 수 있게 해준다.
- `이름-값`이 쌍으로 저장되는데 이를 객체의 `속성`이라고 한다.
- `속성이름-속성값`

```js
const person = {
  name: "윤아준", // 속성 이름 - 'name', 속성 값 - '윤아준'
  age: 19, // 속성 이름 - 'age', 속성 값 - 19
  languages: ["Korean", "English"], // 속성 이름 - 'languages', 속성 값 - 배열
  "한국 나이": 20 // 속성 이름 - '한국 나이', 속성 값 - 20
};
```

- 식별자 이름의 규칙을 만족하는 속성 이름을 사용할 때에는 따옴표를 생략해도 상관없다.
- 속성 이름은 문자열만 가능.
- 객체 리터럴에서 속성값에는 어떤 표현식이 와도 상관없다.

```js
const name = "윤아준";
const person = {
  // 중괄호 안을 객체 리터럴이라고 한다.
  name: name,
  // 왼쪽 name은 속성이름인 문자열, 오른쪽 이름은 표현식.
  // name, 으로 축약할 수 있다.
  age: 19
};
```

- 빈 객체 생성

```js
const obj = {};
```

---
### 점 표기법 vs 대괄호 표기법

- 식별자 이름의 규칙을 만족하지 않는 속성 이름은 점 표기법을 사용할 수 없다. 대괄효 표기법을 사용해야 한다.
- 즉, 식별자 이름의 규칙을 만족하는 속성만 점 표기법을 이용해 접근할 수 있다.
- 기본적으로는 점 표기법을 쓴다.

---
### this

- 해당 메소드를 갖고 있는 객체에 접근.

*화살표 함수와 일반 함수에서의 this 의 동작 방식이 다르다.*
_왜?_

---
### 생성자

- 어떤 함수 앞에 `new`를 붙여 호출하면 객체가 만들어진다.
- 생성자와 일반 함수와의 차이는 없다. 우리가 그냥 이 함수를 생성자로 사용하면 생성자고, 일반 함수로 사용하면 그냥 일반 함수다. 이것이 JS 의 부족한 점.
- 그래서 생성자인 함수 이름은 대문자로 시작하는 것이 best practice 다.
- **ES2015(ES6)에 클래스 추가됨!!**

---
### 인스턴스

- 생성자를 통해 생성된 객체를 그 생성자의 `인스턴스`라고 부른다.
- 인스턴스 확인 코드
```js
person1 instanceof Person; // true
```
- person1 이라는 객체는 Person 으로부터 생성됬다.

---
### 프로토타입

- 메소드를 넣는 방법에는 프로토타입을 이용하는 방법도 있다.
- 프로토타입은 메소드를 넣는 방법이다.
- 메소드와 프로토타입의 관계?

---
### 배열

- 배열은 객체의 일종.
- JS 에 내장되어 있는 자료구조.
- 배열 요소로는 어떠한 표현식도 올 수 있다. 표현식의 결과값이 요소로 저장된다.
- 배열 안에는 뭐든지 저장 가능. 객체, 함수, 배열 등등 모두가 배열의 요소가 될 수 있다.
- `Array.of` 는 항상 인수가 들어있는 배열을 생성한다. 생성자의 단점을 보완하기 위해 만들어진 메소드.

```js
new Array(1, 2, 3); // 이렇게 하지 마세요!
Array.of(1, 2, 3); // 대신 이렇게 하세요.
```

- `Array.from`
- `push` & `pop`
- `unshift` & `shift`
- `splice` 요소를 바꿔주면서 그 바꿔지는 요소들을 반환값으로 돌려줌.
- `pop`, `shift`도 마찬가지. 삭제되는 요소를 반환값으로 돌려줌.
- 원본 배열에 영향을 미치지 않고 작업을 하고 싶을 때 배열을 복사해준다. 복사하기 위해 사용하는 메소드는 `slice` 많이 쓴다.
- `sort`함수를 쓸 때에는 **반드시 비교함수를 넘겨줘야 한다.** 왜냐하면 인자를 넘겨주지 않으면 모든 요소를 문자열로 변환 후 유니코드 코드포인트 순으로 정렬을 해버린다. 
```js
[20, 3, 100].sort((x, y) => x - y); // [3, 20, 100]
```
- `map` 배열의 각 요소에 어떠한 계산을 적용시킨 후 새로운 배열로 만들어서 반환하고 싶을 때.

**객체 vs 배열**
- 배열에는 순서가 있고, 객체에는 순서가 없다.

---
### for...of vs forEach vs for
- `for...of` - index가 필요없고 단순 순회 목적
- `for...of` - index를 쓸 수 없다.
- `for...of` - const를 쓸 수 있다. 블록 스코프를 갖는다.
```js
for(const i of arr){
  console.log(i);
}
```
- `for` - 가장 빠르다. 실행 속도가 중요할 때 쓴다.
- `forEach` - 인덱스가 필요한 경우에 쓴다.

---
### 문자열과 배열은 하나의 요소만 뽑아서 바꿀 수 없다!!


---
## 2. Today I found Out

서형:
```
JS 파이팅! 알고리즘 파이팅!
```

지혜:
```
```